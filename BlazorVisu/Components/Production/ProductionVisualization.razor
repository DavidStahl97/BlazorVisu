@using BlazorVisu.Models
@using BlazorVisu.Services
@using Radzen
@using Radzen.Blazor
@inject IProductionService ProductionService
@implements IDisposable

<svg viewBox="0 0 1000 800" class="production-svg">

        <!-- Machine -->
        <g class="station machine" transform="translate(@GetMachinePosition().X, @GetMachinePosition().Y)">
            <!-- Shadow -->
            <rect width="120" height="80" rx="4" x="2" y="2"
                  fill="rgba(0,0,0,0.1)"/>
            <!-- Main button -->
            <rect width="120" height="80" rx="4"
                  fill="@GetStatusColor(ProductionData.Machine.Status)"
                  stroke="@GetBorderColor(ProductionData.Machine.Status)" stroke-width="1"/>
            <text x="60" y="45" text-anchor="middle" class="station-text">@ProductionData.Machine.Name</text>

            <!-- Production indicator -->
            @if (ProductionData.Machine.Status == StationStatus.Running)
            {
                <circle cx="105" cy="12" r="4" fill="white">
                    <animate attributeName="opacity" values="1;0.3;1" dur="1s" repeatCount="indefinite"/>
                </circle>
            }
        </g>

        <!-- Switches -->
        @for (int i = 0; i < ProductionData.Switches.Count; i++)
        {
            var switchStation = ProductionData.Switches[i];
            var switchPos = GetSwitchPosition(i);
            <g class="station switch" transform="translate(@switchPos.X, @switchPos.Y)">
                <!-- Shadow -->
                <rect width="80" height="80" rx="4" x="2" y="2"
                      fill="rgba(0,0,0,0.1)"/>
                <!-- Main button -->
                <rect width="80" height="80" rx="4"
                      fill="@GetStatusColor(switchStation.Status)"
                      stroke="@GetBorderColor(switchStation.Status)" stroke-width="1"/>
                <text x="40" y="45" text-anchor="middle" class="station-text">@switchStation.Name</text>

                @if (switchStation.Status == StationStatus.Running)
                {
                    <circle cx="65" cy="15" r="3" fill="white">
                        <animate attributeName="opacity" values="1;0.3;1" dur="0.8s" repeatCount="indefinite"/>
                    </circle>
                }
            </g>
        }

        <!-- Consumers -->
        @for (int i = 0; i < ProductionData.Consumers.Count; i++)
        {
            var consumer = ProductionData.Consumers[i];
            var consumerPos = GetConsumerPosition(i);
            <g class="station consumer" transform="translate(@consumerPos.X, @consumerPos.Y)">
                <!-- Shadow -->
                <rect width="90" height="60" rx="4" x="2" y="2"
                      fill="rgba(0,0,0,0.1)"/>
                <!-- Main button -->
                <rect width="90" height="60" rx="4"
                      fill="@GetStatusColor(consumer.Status)"
                      stroke="@GetBorderColor(consumer.Status)" stroke-width="1"/>
                <text x="45" y="35" text-anchor="middle" class="station-text">@consumer.Name</text>

                @if (consumer.Status == StationStatus.Running)
                {
                    <circle cx="78" cy="10" r="3" fill="white">
                        <animate attributeName="opacity" values="1;0.3;1" dur="1.2s" repeatCount="indefinite"/>
                    </circle>
                }
            </g>
        }

        <!-- Connection Lines -->
        <!-- Machine to Switches -->
        @for (int i = 0; i < ProductionData.Switches.Count; i++)
        {
            var switchStation = ProductionData.Switches[i];
            var machinePos = GetMachinePosition();
            var switchPos = GetSwitchPosition(i);
            var machineX = machinePos.X + 60; // Machine Mitte (120px/2)
            var machineY = machinePos.Y + 80; // Machine Unten
            var switchX = switchPos.X + 40; // Switch Mitte (80px/2)
            var switchY = switchPos.Y; // Switch Oben
            var isActiveRoute = IsActiveTransportRoute(null, switchStation.Id);

            <line x1="@machineX" y1="@machineY" x2="@switchX" y2="@switchY"
                  stroke="@(isActiveRoute ? "#4caf50" : "#666")"
                  stroke-width="@(isActiveRoute ? 4 : 3)"
                  stroke-dasharray="@(isActiveRoute ? "5,5" : "none")">
                @if (isActiveRoute)
                {
                    <animate attributeName="stroke-dashoffset" values="10;0" dur="1s" repeatCount="indefinite"/>
                }
            </line>
        }

        <!-- Switch to Consumers -->
        @for (int i = 0; i < ProductionData.Consumers.Count; i++)
        {
            var consumer = ProductionData.Consumers[i];
            var switchIndex = ProductionData.Switches.FindIndex(s => s.Id == consumer.SwitchId);
            if (switchIndex >= 0)
            {
                var switchPos = GetSwitchPosition(switchIndex);
                var consumerPos = GetConsumerPosition(i);
                var switchX = switchPos.X + 40; // Switch Mitte (80px/2)
                var switchY = switchPos.Y + 80; // Switch Unten
                var consumerX = consumerPos.X + 45; // Consumer Mitte (90px/2)
                var consumerY = consumerPos.Y; // Consumer Oben
                var isActiveRoute = IsActiveTransportRoute(consumer.SwitchId, consumer.Id);

                <line x1="@switchX" y1="@switchY" x2="@consumerX" y2="@consumerY"
                      stroke="@(isActiveRoute ? "#4caf50" : "#666")"
                      stroke-width="@(isActiveRoute ? 3 : 2)"
                      stroke-dasharray="@(isActiveRoute ? "3,3" : "none")">
                    @if (isActiveRoute)
                    {
                        <animate attributeName="stroke-dashoffset" values="6;0" dur="0.8s" repeatCount="indefinite"/>
                    }
                </line>
            }
        }

        <!-- Animated Components in Transit -->
        @foreach (var component in ComponentsInTransit)
        {
            <circle r="8" fill="@GetComponentColor(component.Type)" stroke="#333" stroke-width="2">
                <animateMotion dur="3s" repeatCount="indefinite"
                               path="@GetComponentPath(component)"/>
            </circle>
        }

</svg>

<style>
    body, html {
        overflow: hidden !important;
        margin: 0 !important;
        padding: 0 !important;
    }

    .rz-content-container {
        padding: 0 !important;
        margin: 0 !important;
        height: 100vh !important;
        overflow: hidden !important;
    }

    .production-svg {
        width: 100%;
        height: 100vh;
        display: block;
    }

    .station-text {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        font-size: 14px;
        font-weight: 500;
        fill: white;
        text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
    }


    .station {
        /* No hover effects or cursor pointer - static display */
    }
</style>

@code {
    [Parameter] public ProductionSystem ProductionData { get; set; } = new();

    private List<Component> ComponentsInTransit => ProductionData.ComponentsInTransit;
    private TransportRoute _currentTransportRoute = new();

    protected override void OnInitialized()
    {
        ProductionService.TransportRouteChanged += OnTransportRouteChanged;
        _currentTransportRoute = ProductionData.CurrentTransportRoute;
    }

    private void OnTransportRouteChanged(object? sender, TransportRoute route)
    {
        _currentTransportRoute = route;
        InvokeAsync(StateHasChanged);
    }

    private bool IsActiveTransportRoute(string? switchId, string targetId)
    {
        if (!_currentTransportRoute.IsActive)
            return false;

        // For machine to switch connections
        if (switchId == null)
            return targetId == _currentTransportRoute.TargetSwitchId;

        // For switch to consumer connections
        return switchId == _currentTransportRoute.TargetSwitchId &&
               targetId == _currentTransportRoute.TargetConsumerId;
    }

    public void Dispose()
    {
        ProductionService.TransportRouteChanged -= OnTransportRouteChanged;
    }

    private Position GetMachinePosition()
    {
        // Machine horizontal zentriert basierend auf viewBox="0 0 1000 800"
        // SVG nimmt jetzt den Content-Bereich ein (ohne Sidebar)
        const int viewBoxWidth = 1000; // ViewBox bleibt gleich
        const int machineWidth = 120;
        const int shadowOffset = 2;

        var centeredX = (viewBoxWidth - machineWidth) / 2 - shadowOffset;

        return new Position { X = centeredX, Y = 50 };
    }

    private Position GetSwitchPosition(int switchIndex)
    {
        // Switch horizontal zentriert über seiner Consumer-Gruppe
        const int switchWidth = 80;
        const int shadowOffset = 2; // Shadow-Effekt kompensieren

        // Berechne die Consumer-Gruppierung (5 Consumer pro Switch)
        var consumersPerSwitch = ProductionData.Consumers.Count / ProductionData.Switches.Count;

        // Consumer-Dimensionen und Spacing (gleich wie in GetConsumerPosition)
        const int consumerWidth = 90;
        const int consumerSpacing = 15;
        var totalWidthPerConsumer = consumerWidth + consumerSpacing;
        var groupWidth = consumersPerSwitch * totalWidthPerConsumer - consumerSpacing;

        // Berechne die Start-Position der Consumer-Gruppe für diesen Switch
        const int viewBoxWidth = 1000;
        const int groupSpacing = 80; // Abstand zwischen den beiden Consumer-Gruppen
        var totalContentWidth = (groupWidth * 2) + groupSpacing;
        var contentStartX = (viewBoxWidth - totalContentWidth) / 2;

        // Startpositionen für beide Gruppen
        var group1StartX = contentStartX;
        var group2StartX = contentStartX + groupWidth + groupSpacing;

        var groupStartX = switchIndex == 0 ? group1StartX : group2StartX;

        // Switch in der Mitte der Consumer-Gruppe positionieren
        var switchCenterX = groupStartX + (groupWidth / 2) - (switchWidth / 2) - shadowOffset;

        return new Position { X = (int)switchCenterX, Y = 300 };
    }

    private Position GetConsumerPosition(int consumerIndex)
    {
        // Consumer-Dimensionen: 90px breit, 60px hoch (verkleinert)
        const int consumerWidth = 90;
        const int consumerSpacing = 15; // Reduzierter Abstand

        var consumersPerSwitch = ProductionData.Consumers.Count / ProductionData.Switches.Count;
        var switchIndex = consumerIndex / consumersPerSwitch;
        var consumerInSwitch = consumerIndex % consumersPerSwitch;

        // Berechne X-Position basierend auf Consumer-Breite + Spacing
        var totalWidthPerConsumer = consumerWidth + consumerSpacing;
        var groupWidth = consumersPerSwitch * totalWidthPerConsumer - consumerSpacing;

        // Verwende die gesamte verfügbare Breite besser aus
        const int viewBoxWidth = 1000;
        const int groupSpacing = 80; // Abstand zwischen den beiden Consumer-Gruppen
        var totalContentWidth = (groupWidth * 2) + groupSpacing;
        var contentStartX = (viewBoxWidth - totalContentWidth) / 2;

        // Startpositionen für beide Gruppen
        var group1StartX = contentStartX;
        var group2StartX = contentStartX + groupWidth + groupSpacing;

        const int shadowOffset = 2; // Shadow-Effekt kompensieren

        var startX = switchIndex == 0 ? group1StartX : group2StartX;
        var xPosition = startX + (consumerInSwitch * totalWidthPerConsumer) - shadowOffset;

        return new Position { X = (int)xPosition, Y = 550 }; // Alle Consumer unten auf gleicher Höhe
    }

    private string GetStatusColor(StationStatus status) => status switch
    {
        StationStatus.Running => "#4caf50",     // Material Green
        StationStatus.Stopped => "#ff9800",     // Material Orange
        StationStatus.Error => "#f44336",       // Material Red
        StationStatus.Maintenance => "#2196f3", // Material Blue
        _ => "#9e9e9e"                          // Material Gray
    };

    private string GetBorderColor(StationStatus status) => status switch
    {
        StationStatus.Running => "#388e3c",     // Darker Green
        StationStatus.Stopped => "#f57c00",     // Darker Orange
        StationStatus.Error => "#d32f2f",       // Darker Red
        StationStatus.Maintenance => "#1976d2", // Darker Blue
        _ => "#757575"                          // Darker Gray
    };

    private string GetComponentColor(ComponentType type) => type switch
    {
        ComponentType.TypeA => "#007bff",  // Blue
        ComponentType.TypeB => "#28a745",  // Green
        ComponentType.TypeC => "#dc3545",  // Red
        _ => "#6c757d"                     // Gray
    };

    private string GetComponentPath(Component component)
    {
        if (component.CurrentStationId == ProductionData.Machine.Id)
        {
            // Component is at machine - path to first switch
            var machinePos = GetMachinePosition();
            var switchPos = GetSwitchPosition(0);
            var machineX = machinePos.X + 120;
            var machineY = machinePos.Y + 40;
            var switchX = switchPos.X;
            var switchY = switchPos.Y + 40;
            return $"M {machineX} {machineY} L {switchX} {switchY}";
        }
        else if (component.CurrentStationId?.StartsWith("SWITCH") == true)
        {
            // Component is at switch - path to first consumer of that switch
            var switchIndex = ProductionData.Switches.FindIndex(s => s.Id == component.CurrentStationId);
            if (switchIndex >= 0)
            {
                var consumerIndex = ProductionData.Consumers.FindIndex(c => c.SwitchId == component.CurrentStationId);
                if (consumerIndex >= 0)
                {
                    var switchPos = GetSwitchPosition(switchIndex);
                    var consumerPos = GetConsumerPosition(consumerIndex);
                    var switchX = switchPos.X + 80;
                    var switchY = switchPos.Y + 40;
                    var consumerX = consumerPos.X;
                    var consumerY = consumerPos.Y + 40;
                    return $"M {switchX} {switchY} L {consumerX} {consumerY}";
                }
            }
        }
        else if (component.CurrentStationId?.StartsWith("CONSUMER") == true)
        {
            // Component is at consumer - find its position
            var consumerIndex = ProductionData.Consumers.FindIndex(c => c.Id == component.CurrentStationId);
            if (consumerIndex >= 0)
            {
                var consumer = ProductionData.Consumers[consumerIndex];
                var switchIndex = ProductionData.Switches.FindIndex(s => s.Id == consumer.SwitchId);
                if (switchIndex >= 0)
                {
                    var switchPos = GetSwitchPosition(switchIndex);
                    var consumerPos = GetConsumerPosition(consumerIndex);
                    var switchX = switchPos.X + 80;
                    var switchY = switchPos.Y + 40;
                    var consumerX = consumerPos.X;
                    var consumerY = consumerPos.Y + 40;
                    return $"M {switchX} {switchY} L {consumerX} {consumerY}";
                }
            }
        }

        // Default fallback path - machine to first switch
        var defaultMachinePos = GetMachinePosition();
        var defaultSwitchPos = GetSwitchPosition(0);
        var defaultMachineX = defaultMachinePos.X + 120;
        var defaultMachineY = defaultMachinePos.Y + 40;
        var defaultSwitchX = defaultSwitchPos.X;
        var defaultSwitchY = defaultSwitchPos.Y + 40;
        return $"M {defaultMachineX} {defaultMachineY} L {defaultSwitchX} {defaultSwitchY}";
    }
}